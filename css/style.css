/**

  COLORS:
  Light green: #7ed56f
  Primary green: #55c57a
  Dark green: #28b485

  Note: It is actually better to use rem as the unit of choice. This is because if the font size of the page changes, then all the other elements will scale nicely with this. This way, if the user zooms into the page, the elements will still maintain similar aspect ratios

  Generally, it is not advised to use em's. This is because, it will take a lot of calculations to get  the units right. ems will depend on the size of the parent element

  Note: This SCSS file has been derived from ../css/style.css. ../css/style.css was converted into this SCSS file

  Note: This project is also using the 7-1 architecture pattern, where we have one main SASS file to import all the other SASS files. The two folders that are notably missing in this project are themes and vendors. For now, we will not have custom themes. We are also not using any third party vendors css. So these folders have not been created. The end goal is to have no code in the main file. All this will do is import other css files

  Note: SCSS and SASS extensions both use the same preprocessor. The main difference is that the syntax in SCSS is easier to read. SCSS with brackets, where as SASS files are more like python
*/
/**
  Note: We are not using base/_base.scss
  SASS is smart enough to understand without us having to explicitly specify these values
*/
/**
    When we use the float layout, it will force the elements to have 0 height. This is not a desirable behavior. This is because it will also not take into consideration the specified margins.

    clearfix will attempt to fix this issue. https://www.w3schools.com/howto/howto_css_clearfix.asp

    TLDR -> Clear fix will append a pseudo element. This pseudo element will then clear the floats. This workaround will then respect the margins specified
*/
/**
  114 rem is like a standard width used for a row
  We use the max-width as this makes it easier to organize elements. Using the max-width will mean that we do not need to worry to much about how things will look on higher resolution displays
*/
/**
  This is the space between the rows
*/
/**
  This is the space in between the columns
*/
/**
  This is how to add animations
  For the performance sakes, it is best to animate just one or two things
*/
@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem); }
  50% {
    opacity: 0.5; }
  80% {
    opacity: 0.5;
    transform: translateX(2rem); }
  100% {
    opacity: 1;
    transform: translateX(0); } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem); }
  50% {
    opacity: 0.5; }
  80% {
    transform: translateX(-2rem); }
  100% {
    opacity: 1;
    transform: translateX(0); } }

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem); }
  50% {
    opacity: 0.5; }
  100% {
    opacity: 1;
    transform: translateY(0); } }

/**
  Note: This is a partial file. This is why it is following the _ naming convention at the start of the file
*/
/**
  This is how to declare a universal selector 
  We also want to make sure that the after and before pseudo elements also have the same behaviors 
*/
*,
*::after,
*::before {
  /**
    By default, the browser will add some padding and margins to the page. The code below will prevent that from happening 
  */
  margin: 0;
  padding: 0;
  /**
    We are telling if nothing is defined, by default all the elements should inherit the properties for the box sizing 
  */
  box-sizing: inherit; }

/**
  This is how we can modify the root properties. These are the new values that will be used when using rem as the unit 
*/
html {
  /**
    Setting the root font-size to 10, just to make it easier for future calculations 
  */
  /**
    By default, most of the browsers will use a font size of 16. To convert 16 to 10, 10/16 * 100 = 62.5%  
  */
  /**
    Note: Since we are changing the root font-size here, we could make the argument that this bit should be moved into typography. However, we are actually changing the overall setting. It makes more sense to keep this here for now. This setting is defining what 1REM is. 
  */
  font-size: 62.5%; }

/**
 In this page, everything is container within the body. This is the style that will be applied by default. 
*/
body {
  box-sizing: border-box; }

.heading-primary {
  /**
    heading-primary can again be considered component or a typography. It makes more sense to put it in typography as this bit of code is dealing with how the text is displayed. 
  */
  color: #fff;
  text-transform: uppercase;
  /**
    Sometimes when the animations play, it can be a bit shaky. Setting this property fixes it 
  */
  backface-visibility: hidden;
  margin-bottom: 6rem; }
  .heading-primary--main {
    /**
      Displays an element as a block element (like <p>). It starts on a new line, and takes up the whole width 
    */
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation: moveInLeft 1s ease-out; }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out; }

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  font-size: 16;
  line-height: 1.7;
  color: #777;
  padding: 4rem; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  /**
    Without displaying as the inline block, then text styling will span across the entire width of the page
  */
  display: inline-block;
  /**
    Applying the nice gradient color to the text
  */
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  /**
    This will make it so that the background (which is the linear gradient) is applied only to the back of the text.

    Combine this effect and color: transparent to add the nice gradient to the Text
  */
  -webkit-background-clip: text;
  color: transparent;
  letter-spacing: 0.2rem;
  /**
    Adding some animations so to make the text cooler when we hover
  */
  transition: all 0.2s; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem;
  /**
    As the name suggests, we want to apply this style to everything except the last paragraph
  */ }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  text-align: center; }

.u-margin-bottom-big {
  margin-bottom: 8rem; }

.u-margin-bottom-small {
  margin-bottom: 2rem; }

/**
  
  The link here is a pseudo class 
  https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes

  link - How the link should appear
  visited - How the link should appear after the user has clicked on it. By default, the browsers will change the color of the link to indicate the user has visited this before. In this application, we want the link to look exactly the same even after it has been visited
*/
.btn {
  /** 
    Active is for when you click on the element 
  */ }
  .btn:link, .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    /**
      Just 2 numbers will mean top and bottom will be same, left right will be same
    */
    padding: 1.5rem 4rem;
    /**
      inline-block prevents the btn from overlapping on the previous element 
    */
    display: inline-block;
    border-radius: 10rem;
    /**
      All the transformations will now take 0.2s to complete. Without this, all the animations will look jittery 
    */
    transition: all 0.2s;
    /**
      In this case, the after pseudo class will use this to align itself. 
    */
    position: relative;
    font-size: 1.6rem; }
  .btn--white {
    background-color: white;
    color: #777; }
    .btn--white::after {
      background-color: #fff; }
  .btn:hover {
    transform: translateY(-0.3rem);
    /**
      0 - Just in the epsilon or y axis
      10px - The shadow will be 10 px down
      20px - The blur we will see
    */
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.2); }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0; }
  .btn:active {
    transform: translateY(-1px);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.2); }
  .btn::after {
    /**
      For the after pseudo element to appear, we need to specify the content. Doesn't matter even if it is empty. We need to specify it
    */
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all 0.4s; }
  .btn--animated {
    animation: moveInBottom 0.5s ease-out 0.75s;
    /**
      backwards - This will ensure that all the other CSS is applied before starting the animation,i.e, apply all the styles at 0% and then display the element by playing the animation with the  
    */
    animation-fill-mode: backwards; }

.btn-text {
  transition: all 0.2s; }
  .btn-text:link, .btn-text:visited {
    color: #55c57a;
    display: inline-block;
    text-decoration: none;
    border-bottom: 0.1rem solid #55c57a;
    font-size: 1.6rem; }
  .btn-text:hover {
    background-color: #55c57a;
    color: #fff;
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15);
    transform: translateY(-2px); }
  .btn-text:active {
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    transform: translateY(0px); }

/**
  This will define all the grid like structures that will be used in the project
*/
.row {
  max-width: 114rem;
  /**
    We are saying that the margin on top and bottom is 0. The margins left and right is auto
    What this means is that CSS will automatically try to center the element
  */
  margin: 0 auto;
  /**
    We just want to make sure that there is no margin on the last row
  */
  /**
    Select based on partial class names.
    Here we are selecting all the classes that will start off with col-

    ^= Any class that starts with the specified name
    *= Any class that contains the specified name
    $= Any class that ends with the specified name
  */ }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    /**
        It is important to specify some content. Even if its empty. if not, the element will not be displayed on the screen.
    */
    content: "";
    /**
        display: table; is just a standard version of the clearfix. This is what everyone uses generally speaking
    */
    display: table;
    /**
        This is the actual code that will clear the floats thats been applied to the elements
    */
    clear: both; }
  .row [class^="col-"] {
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - (2 *6rem)) / 3); }

/**
 . is used to select the custom classes 
*/
.header {
  /**
    Header can be considered a component or a layout. It can be considered layout because every page will contain a header. So in other words, the layout of every page will contain a header. 
    vh - view port height. This will make it so that the height of the header will always be 95% of the viewport height 
  */
  height: 95vh;
  /**
    using the comma separator, we can add multiple images. The first one will be the top most image 
  */
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  /**
    cover will try and fit the element into the viewport 
  */
  background-size: cover;
  /**
    This will fix the top of the image in place, the rest of the image will crop to fit the viewport 
  */
  background-position: top;
  /**
    This will allow the header to be clipped based on the specified shape. Inside the polygon function, specify the area of the image that should still be visible 
    corresponding corners: polygon( TL, TR, BR, BL) 
  */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /**
    The child elements will now use this parameter to align them selves 
  */
  position: relative;
  /**
    The & symbol will get translated to .header
    For example &__logo-box is same as .header__logo-box
  */ }
  .header__logo-box {
    position: absolute;
    /**
      Will be positioned 40px from top and left based on the parent element of header. This is because the header has a position attribute set to relative 
    */
    top: 4rem;
    left: 4rem; }
  .header__logo {
    height: 3.5rem; }
  .header__text-box {
    position: absolute;
    /**
      The percentages below are for aligning the text to the middle of the screen 
    */
    top: 40%;
    left: 50%;
    /**
      This will move the origin to the center of the element rather than default of top edge and the left edge 
    */
    transform: translate(-50%, -50%);
    text-align: center; }

/**
    This file will contain the styles that are specific to the home page only
*/
.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  margin-top: -20vh; }
